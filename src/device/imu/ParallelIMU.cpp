#include "ParallelIMU.h"

ParallelIMU::ParallelIMU() {

    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved
    RTIMUSettings *settings = new RTIMUSettings(Resources::getConfigDir().c_str(), "RTIMULib");

    imu_ = RTIMU::createIMU(settings);

    if ((imu_ == NULL) || (imu_->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }

    //  This is an opportunity to manually override any settings before the call IMUInit

    //  set up IMU
    imu_->IMUInit();

    //  this is a convenient place to change fusion parameters
    imu_->setSlerpPower(0.02);
    imu_->setGyroEnable(true);
    imu_->setAccelEnable(true);
    imu_->setCompassEnable(true);

    imuThread_ = std::thread(&ParallelIMU::startCapture, this);
    imuThread_.detach();


}

void ParallelIMU::startCapture() {
    //  now just process data
    while (1) {
        //  poll at the rate recommended by the IMU
        usleep(imu_->IMUGetPollInterval() * 1000);

        while (imu_->IMURead()) {
            lock_.lock();
            imuData_ = imu_->getIMUData();
            lock_.unlock();
        }
    }
}

Orientation ParallelIMU::getOrientation() {
    lock_.lock();

    const Orientation &orientation = Orientation(imuData_.fusionPose.x(),
                                                 imuData_.fusionPose.y(),
                                                 imuData_.fusionPose.z());
    lock_.unlock();

    return orientation;
}
